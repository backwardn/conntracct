// +build integration

package bpf

import (
	"fmt"
	"log"
	"net"
	"os"
	"syscall"
	"testing"
	"time"

	"github.com/pkg/errors"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/ti-mo/conntracct/pkg/udpecho"
	"golang.org/x/sys/unix"
)

// Mock UDP server listen port.
const (
	udpServ = 1342
	cd      = 20
)

var (
	acctProbe      *Probe
	errChanTimeout = errors.New("timeout")
)

func TestMain(m *testing.M) {

	var err error

	cfg := Config{
		Curve0: CurvePoint{
			AgeMillis:      0,
			IntervalMillis: 10,
		},
		Curve1: CurvePoint{
			AgeMillis:      50,
			IntervalMillis: 25,
		},
		Curve2: CurvePoint{
			AgeMillis:      100,
			IntervalMillis: 50,
		},
	}

	// Set the required sysctl's for the probe to gather accounting data.
	err = Sysctls(false)
	if err != nil {
		log.Fatal(err)
	}

	// Create and start the Probe.
	acctProbe, err = NewProbe(cfg)
	if err != nil {
		log.Fatal(err)
	}
	if err := acctProbe.Start(); err != nil {
		log.Fatal(err)
	}
	go errWorker(acctProbe.ErrChan())

	// Create and start the localhost UDP listener.
	c := udpecho.ListenAndEcho(1342)

	// Run tests, save the return code.
	rc := m.Run()

	// Tear down resources.
	acctProbe.Stop()
	c.Close()

	os.Exit(rc)
}

// Checks if the first packet in a flow is logged,
func TestProbeFirstPacket(t *testing.T) {

	// Create and register consumer.
	ac, in := newUpdateConsumer(t)

	// Create UDP client.
	mc := udpecho.Dial(udpServ)

	// Filter BPF Events based on client port.
	out := filterSourcePort(in, mc.ClientPort())

	mc.Ping(1)
	ev, err := readTimeout(out, 5)
	assert.EqualValues(t, 1, ev.PacketsOrig+ev.PacketsRet, ev.String())
	require.NoError(t, err)

	// Further attempt(s) to read from the channel should time out.
	ev, err = readTimeout(out, 10)
	assert.EqualError(t, err, "timeout", ev.String())

	require.NoError(t, acctProbe.RemoveConsumer(ac))
}

// Runs past the 'connection startup burst' events and tries to obtain two
// events generated by sending packets right after the flow's cooldown timer
// expires.
func TestProbeLongterm(t *testing.T) {

	// Create and register consumer.
	ac, in := newUpdateConsumer(t)

	// Create UDP client.
	mc := udpecho.Dial(udpServ)

	// Filter BPF Events based on client port.
	out := filterSourcePort(in, mc.ClientPort())

	// Clear the connection startup burst to make sure it's not interfering
	// with our test suite. Send 16 two-way packets and read 4 events.
	mc.Ping(16)
	for i := 0; i < 4; i++ {
		_, err := readTimeout(out, 10)
		assert.NoError(t, err)
	}

	// Ensure all events are drained.
	ev, err := readTimeout(out, 20)
	assert.EqualError(t, err, "timeout", ev.String())

	// Wait for at least one cooldown period, send a one-way packet.
	time.Sleep(cd * time.Millisecond)
	mc.Nop(1)

	// Expect 33rd packet in this message.
	ev, err = readTimeout(out, 20)
	require.NoError(t, err)
	assert.EqualValues(t, 33, ev.PacketsOrig+ev.PacketsRet, ev.String())

	// Expect 34th packet in this message.
	time.Sleep(cd * time.Millisecond)
	mc.Nop(1)
	ev, err = readTimeout(out, 20)
	require.NoError(t, err)
	assert.EqualValues(t, 34, ev.PacketsOrig+ev.PacketsRet, ev.String())

	// Further attempt(s) to read from the channel should time out.
	ev, err = readTimeout(out, 10)
	assert.EqualError(t, err, "timeout", ev.String())

	require.NoError(t, acctProbe.RemoveConsumer(ac))
}

// Verify as many fields as possible based on information obtained from other
// sources. This checks whether the BPF program is reading the correct offsets
// from kernel memory.
func TestProbeVerify(t *testing.T) {

	// Create and register consumer.
	ac, in := newUpdateConsumer(t)

	// Create UDP client.
	mc := udpecho.Dial(udpServ)

	// Filter BPF Events based on client port.
	out := filterSourcePort(in, mc.ClientPort())

	// Generate a single dummy event.
	mc.Nop(1)
	ev, err := readTimeout(out, 20)
	require.NoError(t, err)

	// Network Namespace
	ns, err := getNSID()
	require.NoError(t, err)
	assert.EqualValues(t, ns, ev.NetNS, ev.String())

	// Connmark (default 0)
	assert.EqualValues(t, 0, ev.Connmark, ev.String())

	// Accounting
	assert.EqualValues(t, 1, ev.PacketsOrig, ev.String())
	assert.EqualValues(t, 31, ev.BytesOrig, ev.String())
	assert.EqualValues(t, 0, ev.PacketsRet, ev.String())
	assert.EqualValues(t, 0, ev.BytesRet, ev.String())

	// Connection tuple
	assert.EqualValues(t, udpServ, ev.DstPort, ev.String())
	assert.EqualValues(t, mc.ClientPort(), ev.SrcPort, ev.String())
	assert.EqualValues(t, net.IPv4(127, 0, 0, 1), ev.SrcAddr, ev.String())
	assert.EqualValues(t, net.IPv4(127, 0, 0, 1), ev.DstAddr, ev.String())
	assert.EqualValues(t, 17, ev.Proto, ev.String())

	require.NoError(t, acctProbe.RemoveConsumer(ac))
}

// filterSourcePort returns an unbuffered channel of Events
// that has its event stream filtered by the given source port.
func filterSourcePort(in chan Event, port uint16) chan Event {
	out := make(chan Event)
	go filterWorker(in, out,
		func(ev Event) bool {
			if ev.SrcPort == port {
				return true
			}
			return false
		})

	return out
}

// filterWorker sends an Event from in to out if the given function f yields true.
func filterWorker(in <-chan Event, out chan<- Event, f func(Event) bool) {
	for {
		ev, ok := <-in
		if !ok {
			close(out)
			return
		}

		if f(ev) {
			out <- ev
		}
	}
}

// errWorker listens for errors on the Probe's error channel.
// Terminates the test suite when an error occurs.
func errWorker(ec <-chan error) {
	for err := range ec {
		log.Fatal("unexpected error from Probe:", err)
	}
}

// readTimeout attempts a read from an Event channel, timing out
// when a message wasn't read after ms milliseconds.
func readTimeout(c <-chan Event, ms uint) (Event, error) {
	select {
	case ev := <-c:
		return ev, nil
	case <-time.After(time.Duration(ms) * time.Millisecond):
		return Event{}, errChanTimeout
	}
}

// newUpdateConsumer creates and registers an Consumer for a test.
func newUpdateConsumer(t *testing.T) (*Consumer, chan Event) {
	c := make(chan Event, 2048)
	ac := NewConsumer(t.Name(), c, ConsumerUpdate)
	require.NoError(t, acctProbe.RegisterConsumer(ac))

	return ac, c
}

// getNSID gets the inode of the current process' network namespace.
func getNSID() (uint64, error) {
	path := fmt.Sprintf("/proc/%d/task/%d/ns/net", os.Getpid(), syscall.Gettid())
	fd, err := unix.Open(path, syscall.O_RDONLY, 0)
	if err != nil {
		return 0, err
	}

	var s unix.Stat_t
	if err := unix.Fstat(fd, &s); err != nil {
		return 0, err
	}

	return s.Ino, nil
}
